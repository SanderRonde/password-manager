import { WebComponentBase } from "./webcomponent-util";

export function bindToClass<T extends Function>(_target: object, propertyKey: string, 
	descriptor: TypedPropertyDescriptor<T>): TypedPropertyDescriptor<T> | void {
		if(!descriptor || (typeof descriptor.value !== 'function')) {
			throw new TypeError(`Only methods can be decorated with @bind. <${propertyKey}> is not a method!`);
		}
		
		return {
			configurable: true,
			get(this: T): T {
				const bound: T = descriptor.value!.bind(this);
				Object.defineProperty(this, propertyKey, {
					value: bound,
					configurable: true,
					writable: true
				});
				return bound;
			}
		};
	}

export interface RippleEffect {
	applyRipple(): void;
	resetRipple(): void;
}
type ExtendableComponent = {new(...args: Array<any>): WebComponentBase};
export function rippleEffect<T extends ExtendableComponent>(target: T): T {
	return class Rippled extends target implements RippleEffect {
		private _rippleElement!: HTMLElement|null;
		private _rippleSize!: number;
		private _ignoringMouseDown!: boolean;
		private _frameCount!: number;
		private _x!: number;
		private _y!: number;
		
		protected container!: HTMLElement;

		constructor(...args: any[]) {
			super(...args);
		}

		private _downHandler(event: MouseEvent) {
			if (!this._rippleElement!.style.width && !this._rippleElement!.style.height) {
				var rect = this.container.getBoundingClientRect();
				this._rippleSize = Math.sqrt(rect.width * rect.width +
					rect.height * rect.height) * 2 + 2;
				this._rippleElement!.style.width = this._rippleSize + 'px';
				this._rippleElement!.style.height = this._rippleSize + 'px';
				}

				this._rippleElement!.classList.add('is-visible');

				if (event.type === 'mousedown' && this._ignoringMouseDown) {
					this._ignoringMouseDown = false;
				} else {
				if (event.type === 'touchstart') {
					this._ignoringMouseDown = true;
				}
				var frameCount = this._getFrameCount();
				if (frameCount > 0) {
					return;
				}
				this._setFrameCount(1);
				var bound = (event.currentTarget! as HTMLElement).getBoundingClientRect();
				var x;
				var y;
				// Check if we are handling a keyboard click.
				if (event.clientX === 0 && event.clientY === 0) {
					x = Math.round(bound.width / 2);
					y = Math.round(bound.height / 2);
				} else {
					var clientX = event.clientX !== undefined ? event.clientX : (event as any).touches[0].clientX;
					var clientY = event.clientY !== undefined ? event.clientY : (event as any).touches[0].clientY;
					x = Math.round(clientX - bound.left);
					y = Math.round(clientY - bound.top);
				}
				this._setRippleXY(x, y);
				this._setRippleStyles(true);
				window.requestAnimationFrame(this._animFrameHandler.bind(this));
			}
		}

		private _upHandler(event: MouseEvent) {
			// Don't fire for the artificial "mouseup" generated by a double-click.
			if (event && event.detail !== 2) {
				// Allow a repaint to occur before removing this class, so the animation
				// shows for tap events, which seem to trigger a mouseup too soon after
				// mousedown.
				window.setTimeout(() => {
					this._rippleElement!.classList.remove('is-visible');
				}, 0);
			}
		};

		private _getFrameCount() {
			return this._frameCount;
		};

		private _setFrameCount(frameCount: number) {
			this._frameCount = frameCount;
		};

		private _setRippleXY(newX: number, newY: number) {
			this._x = newX;
			this._y = newY;
		};

		/**
		 * Sets the ripple styles.
		 * @param  {boolean} start whether or not this is the start frame.
		 */
		private _setRippleStyles(start: boolean) {
			if (this._rippleElement! !== null) {
				var transformString;
				var scale;
				var offset = 'translate(' + this._x + 'px, ' + this._y + 'px)';

				if (start) {
					scale = 'scale(0.0001, 0.0001)';
				} else {
					scale = '';
				}

				transformString = 'translate(-50%, -50%) ' + offset + scale;

				this._rippleElement!.style.webkitTransform = transformString;
				this._rippleElement!.style.transform = transformString;

				if (start) {
					this._rippleElement!.classList.remove('is-animating');
				} else {
					this._rippleElement!.classList.add('is-animating');
				}
			}
		};

		/**
		 * Handles an animation frame.
		 */
		private _animFrameHandler() {
			if (this._frameCount-- > 0) {
			window.requestAnimationFrame(this._animFrameHandler.bind(this));
			} else {
			this._setRippleStyles(false);
			}
		};

		applyRipple() {
			if (!this.container.classList.contains('mdl-js-ripple-effect--ignore-events')) {
				this._rippleElement = this.container.querySelector('.mdl-ripple');
				this._frameCount = 0;
				this._rippleSize = 0;
				this._x = 0;
				this._y = 0;
		
				// Touch start produces a compat mouse down event, which would cause a
				// second ripples. To avoid that, we use this property to ignore the first
				// mouse down after a touch start.
				this._ignoringMouseDown = false;
		
				this.container.addEventListener('mousedown',
					this._downHandler.bind(this));
				this.container.addEventListener('touchstart',
					this._downHandler.bind(this));
		
				this.container.addEventListener('mouseup', this._upHandler.bind(this));
				this.container.addEventListener('mouseleave', this._upHandler.bind(this));
				this.container.addEventListener('touchend', this._upHandler.bind(this));
				this.container.addEventListener('blur', this._upHandler.bind(this));
			}
		}

		resetRipple() {

		}
	}
}